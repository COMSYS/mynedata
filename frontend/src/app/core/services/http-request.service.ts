import { Injectable } from '@angular/core';
import {environment as env} from '../../../environments/environment';
import {HttpClient, HttpHeaderResponse, HttpHeaders} from '@angular/common/http';
import {LoggerService} from './logger.service';
import {SessionService} from './session.service';
import {AuthenticationService} from './authentication.service';

@Injectable({
  providedIn: 'root'
})
export class HttpRequestService {

  private _baseURL: string = env.apiBaseURL;
  private _apiPath: string = env.apiPath;

  constructor(private http: HttpClient, private logger: LoggerService, private _authenticationService: AuthenticationService) { }

  public post(url: string, body: Object): Promise<any> {
    this._printUpcomingRequestAction({method: 'POST', url: url});
    const headers: HttpHeaders = this._buildHeader();
    return this.http.post(this._buildUrl(url), body, { headers: headers}).toPromise().then((res) => {
      return this._handleSuccessfulResponse(res);
    }).catch((error) => {
      return this._handleFailedResponse(error, 'POST');
    });
  }

  public get(url: string): Promise<any> {
    this._printUpcomingRequestAction({method: 'GET', url: url});
    const headers: HttpHeaders = this._buildHeader();
    return this.http.get<string>(this._buildUrl(url), { headers: headers}).toPromise().then((res) => {
      return this._handleSuccessfulResponse(res);
  }).catch((error) => {
      return this._handleFailedResponse(error, 'GET');
    });
  }

  public delete(url: string): Promise<any> {
    this._printUpcomingRequestAction({method: 'DELETE', url: url});
    const headers: HttpHeaders = this._buildHeader();
    return this.http.delete(this._buildUrl(url), { headers: headers}).toPromise().then((res) => {
      return this._handleSuccessfulResponse(res);
    }).catch((error) => {
      return this._handleFailedResponse(error, 'DELETE');
    });
  }

  public patch(url: string, body: Object): Promise<any> {
    this._printUpcomingRequestAction({method: 'PATCH', url: url});
    const headers: HttpHeaders = this._buildHeader();
    return this.http.patch<string>(this._buildUrl(url), body, { headers: headers}).toPromise().then((res) => {
      return this._handleSuccessfulResponse(res);
    }).catch((error) => {
      return this._handleFailedResponse(error, 'PATCH');
    });
  }

  private _handleSuccessfulResponse(res: any): Promise<any> {
    this.logger.print('API responds: ', res);
    // at least the request to register a new query does not have a response field, so no using it for check-up right now
    if (res && res['success']) {
      return Promise.resolve(res['response']);
    } else {
      return Promise.reject(res);
    }
  }

  private _handleFailedResponse(error: Error, method: string) {
    if (error && error !== undefined && error != null) {
      this.logger.print(error);
      return Promise.reject(error);
    } else {
      return Promise.reject(new Error(
        `This error was generated by the receiving ${method} function inside HttpRequestService which got a rejected promise with an UNDEFINED reason`
      ));
    }
  }

  private _printUpcomingRequestAction(info: {method: string, url: string}) {
    this.logger.print(`Attempting to send HTTP ${info.method} to URL ${info.url}`);
  }

  private _buildHeader(): HttpHeaders {
    let headers: HttpHeaders = new HttpHeaders({
      'Content-Type': 'application/json'
    });
    headers = this._authenticationService.addTokenToHeaders(headers);
    return headers;
  }

  private _buildUrl(_suffixUrl): string {
    return `${this._apiPath}${this._baseURL}${_suffixUrl}`;
  }

  public __dev_debugComputeAdhoc(procName: string, queryId: number): Promise<any> {
    const url = `/processor/${procName}/query_info/${queryId}`;
    this._printUpcomingRequestAction({method: 'GET', url: url});
    const headers: HttpHeaders = this._buildHeader().append('debugComputeAdhoc', 'True');
    return this.http.get(this._buildUrl(url), { headers: headers}).toPromise().then((res) => {
      return this._handleSuccessfulResponse(res);
    }).catch((error) => {
      return this._handleFailedResponse(error, 'GET');
    });
  }
}
